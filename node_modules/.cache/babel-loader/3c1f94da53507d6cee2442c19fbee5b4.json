{"ast":null,"code":"var buildSearchMethod = require('./buildSearchMethod.js');\n\nvar deprecate = require('./deprecate.js');\n\nvar deprecatedMessage = require('./deprecatedMessage.js');\n\nmodule.exports = IndexCore;\n/*\n* Index class constructor.\n* You should not use this method directly but use initIndex() function\n*/\n\nfunction IndexCore(algoliasearch, indexName) {\n  this.indexName = indexName;\n  this.as = algoliasearch;\n  this.typeAheadArgs = null;\n  this.typeAheadValueOption = null; // make sure every index instance has it's own cache\n\n  this.cache = {};\n}\n/*\n* Clear all queries in cache\n*/\n\n\nIndexCore.prototype.clearCache = function () {\n  this.cache = {};\n};\n/*\n* Search inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the full text query\n* @param {object} [args] (optional) if set, contains an object with query parameters:\n* - page: (integer) Pagination parameter used to select the page to retrieve.\n*                   Page is zero-based and defaults to 0. Thus,\n*                   to retrieve the 10th page you need to set page=9\n* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.\n* - attributesToRetrieve: a string that contains the list of object attributes\n* you want to retrieve (let you minimize the answer size).\n*   Attributes are separated with a comma (for example \"name,address\").\n*   You can also use an array (for example [\"name\",\"address\"]).\n*   By default, all attributes are retrieved. You can also use '*' to retrieve all\n*   values when an attributesToRetrieve setting is specified for your index.\n* - attributesToHighlight: a string that contains the list of attributes you\n*   want to highlight according to the query.\n*   Attributes are separated by a comma. You can also use an array (for example [\"name\",\"address\"]).\n*   If an attribute has no match for the query, the raw value is returned.\n*   By default all indexed text attributes are highlighted.\n*   You can use `*` if you want to highlight all textual attributes.\n*   Numerical attributes are not highlighted.\n*   A matchLevel is returned for each highlighted attribute and can contain:\n*      - full: if all the query terms were found in the attribute,\n*      - partial: if only some of the query terms were found,\n*      - none: if none of the query terms were found.\n* - attributesToSnippet: a string that contains the list of attributes to snippet alongside\n* the number of words to return (syntax is `attributeName:nbWords`).\n*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).\n*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).\n*    By default no snippet is computed.\n* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.\n* Defaults to 3.\n* - minWordSizefor2Typos: the minimum number of characters in a query word\n* to accept two typos in this word. Defaults to 7.\n* - getRankingInfo: if set to 1, the result hits will contain ranking\n* information in _rankingInfo attribute.\n* - aroundLatLng: search for entries around a given\n* latitude/longitude (specified as two floats separated by a comma).\n*   For example aroundLatLng=47.316669,5.016670).\n*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)\n*   and the precision for ranking with aroundPrecision\n*   (for example if you set aroundPrecision=100, two objects that are distant of\n*   less than 100m will be considered as identical for \"geo\" ranking parameter).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - insideBoundingBox: search entries inside a given area defined by the two extreme points\n* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).\n*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - numericFilters: a string that contains the list of numeric filters you want to\n* apply separated by a comma.\n*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.\n*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.\n*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.\n*   You can also use an array (for example numericFilters: [\"price>100\",\"price<1000\"]).\n* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.\n*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).\n*   You can also use an array, for example tagFilters: [\"tag1\",[\"tag2\",\"tag3\"]]\n*   means tag1 AND (tag2 OR tag3).\n*   At indexing, tags should be added in the _tags** attribute\n*   of objects (for example {\"_tags\":[\"tag1\",\"tag2\"]}).\n* - facetFilters: filter the query by a list of facets.\n*   Facets are separated by commas and each facet is encoded as `attributeName:value`.\n*   For example: `facetFilters=category:Book,author:John%20Doe`.\n*   You can also use an array (for example `[\"category:Book\",\"author:John%20Doe\"]`).\n* - facets: List of object attributes that you want to use for faceting.\n*   Comma separated list: `\"category,author\"` or array `['category','author']`\n*   Only attributes that have been added in **attributesForFaceting** index setting\n*   can be used in this parameter.\n*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.\n* - queryType: select how the query words are interpreted, it can be one of the following value:\n*    - prefixAll: all query words are interpreted as prefixes,\n*    - prefixLast: only the last word is interpreted as a prefix (default behavior),\n*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.\n* - optionalWords: a string that contains the list of words that should\n* be considered as optional when found in the query.\n*   Comma separated and array are accepted.\n* - distinct: If set to 1, enable the distinct feature (disabled by default)\n* if the attributeForDistinct index setting is set.\n*   This feature is similar to the SQL \"distinct\" keyword: when enabled\n*   in a query with the distinct=1 parameter,\n*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.\n*   For example, if the chosen attribute is show_name and several hits have\n*   the same value for show_name, then only the best\n*   one is kept and others are removed.\n* - restrictSearchableAttributes: List of attributes you want to use for\n* textual search (must be a subset of the attributesToIndex index setting)\n* either comma separated or as an array\n* @param {function} [callback] the result callback called with two arguments:\n*  error: null or Error('message'). If false, the content contains the error.\n*  content: the server answer that contains the list of results.\n*/\n\n\nIndexCore.prototype.search = buildSearchMethod('query');\n/*\n* -- BETA --\n* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the similar query\n* @param {object} [args] (optional) if set, contains an object with query parameters.\n*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters\n*   are the two most useful to restrict the similar results and get more relevant content\n*/\n\nIndexCore.prototype.similarSearch = deprecate(buildSearchMethod('similarQuery'), deprecatedMessage('index.similarSearch(query[, callback])', 'index.search({ similarQuery: query }[, callback])'));\n/*\n* Browse index content. The response content will have a `cursor` property that you can use\n* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browse('cool songs', {\n*   tagFilters: 'public,comments',\n*   hitsPerPage: 500\n* }, callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\n\nIndexCore.prototype.browse = function (query, queryParameters, callback) {\n  var merge = require('./merge.js');\n\n  var indexObj = this;\n  var page;\n  var hitsPerPage; // we check variadic calls that are not the one defined\n  // .browse()/.browse(fn)\n  // => page = 0\n\n  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {\n    page = 0;\n    callback = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'number') {\n    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)\n    page = arguments[0];\n\n    if (typeof arguments[1] === 'number') {\n      hitsPerPage = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n      hitsPerPage = undefined;\n    }\n\n    query = undefined;\n    queryParameters = undefined;\n  } else if (typeof arguments[0] === 'object') {\n    // .browse(queryParameters)/.browse(queryParameters, cb)\n    if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n    }\n\n    queryParameters = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {\n    // .browse(query, cb)\n    callback = arguments[1];\n    queryParameters = undefined;\n  } // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)\n  // get search query parameters combining various possible calls\n  // to .browse();\n\n\n  queryParameters = merge({}, queryParameters || {}, {\n    page: page,\n    hitsPerPage: hitsPerPage,\n    query: query\n  });\n\n  var params = this.as._getSearchParams(queryParameters, '');\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',\n    body: {\n      params: params\n    },\n    hostType: 'read',\n    callback: callback\n  });\n};\n/*\n* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browseFrom('14lkfsakl32', callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\n\n\nIndexCore.prototype.browseFrom = function (cursor, callback) {\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',\n    body: {\n      cursor: cursor\n    },\n    hostType: 'read',\n    callback: callback\n  });\n};\n/*\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n*\n* @param {string} params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} params.facetQuery Query for the facet search\n* @param {string} [params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n* @param callback (optional)\n*/\n\n\nIndexCore.prototype.searchForFacetValues = function (params, callback) {\n  var clone = require('./clone.js');\n\n  var omit = require('./omit.js');\n\n  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';\n\n  if (params.facetName === undefined || params.facetQuery === undefined) {\n    throw new Error(usage);\n  }\n\n  var facetName = params.facetName;\n  var filteredParams = omit(clone(params), function (keyName) {\n    return keyName === 'facetName';\n  });\n\n  var searchParameters = this.as._getSearchParams(filteredParams, '');\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',\n    hostType: 'read',\n    body: {\n      params: searchParameters\n    },\n    callback: callback\n  });\n};\n\nIndexCore.prototype.searchFacet = deprecate(function (params, callback) {\n  return this.searchForFacetValues(params, callback);\n}, deprecatedMessage('index.searchFacet(params[, callback])', 'index.searchForFacetValues(params[, callback])'));\n\nIndexCore.prototype._search = function (params, url, callback, additionalUA) {\n  return this.as._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',\n    body: {\n      params: params\n    },\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/' + encodeURIComponent(this.indexName),\n      body: {\n        params: params\n      }\n    },\n    callback: callback,\n    additionalUA: additionalUA\n  });\n};\n/*\n* Get an object from this index\n*\n* @param objectID the unique identifier of the object to retrieve\n* @param attrs (optional) if set, contains the array of attribute names to retrieve\n* @param callback (optional) the result callback called with two arguments\n*  error: null or Error('message')\n*  content: the object to retrieve or the error message if a failure occurred\n*/\n\n\nIndexCore.prototype.getObject = function (objectID, attrs, callback) {\n  var indexObj = this;\n\n  if (arguments.length === 1 || typeof attrs === 'function') {\n    callback = attrs;\n    attrs = undefined;\n  }\n\n  var params = '';\n\n  if (attrs !== undefined) {\n    params = '?attributes=';\n\n    for (var i = 0; i < attrs.length; ++i) {\n      if (i !== 0) {\n        params += ',';\n      }\n\n      params += attrs[i];\n    }\n  }\n\n  return this.as._jsonRequest({\n    method: 'GET',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,\n    hostType: 'read',\n    callback: callback\n  });\n};\n/*\n* Get several objects from this index\n*\n* @param objectIDs the array of unique identifier of objects to retrieve\n*/\n\n\nIndexCore.prototype.getObjects = function (objectIDs, attributesToRetrieve, callback) {\n  var isArray = require('isarray');\n\n  var map = require('./map.js');\n\n  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';\n\n  if (!isArray(objectIDs)) {\n    throw new Error(usage);\n  }\n\n  var indexObj = this;\n\n  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {\n    callback = attributesToRetrieve;\n    attributesToRetrieve = undefined;\n  }\n\n  var body = {\n    requests: map(objectIDs, function prepareRequest(objectID) {\n      var request = {\n        indexName: indexObj.indexName,\n        objectID: objectID\n      };\n\n      if (attributesToRetrieve) {\n        request.attributesToRetrieve = attributesToRetrieve.join(',');\n      }\n\n      return request;\n    })\n  };\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/*/objects',\n    hostType: 'read',\n    body: body,\n    callback: callback\n  });\n};\n\nIndexCore.prototype.as = null;\nIndexCore.prototype.indexName = null;\nIndexCore.prototype.typeAheadArgs = null;\nIndexCore.prototype.typeAheadValueOption = null;","map":{"version":3,"sources":["C:/dev/ranaldsgift/node_modules/algoliasearch/src/IndexCore.js"],"names":["buildSearchMethod","require","deprecate","deprecatedMessage","module","exports","IndexCore","algoliasearch","indexName","as","typeAheadArgs","typeAheadValueOption","cache","prototype","clearCache","search","similarSearch","browse","query","queryParameters","callback","merge","indexObj","page","hitsPerPage","arguments","length","undefined","params","_getSearchParams","_jsonRequest","method","url","encodeURIComponent","body","hostType","browseFrom","cursor","searchForFacetValues","clone","omit","usage","facetName","facetQuery","Error","filteredParams","keyName","searchParameters","searchFacet","_search","additionalUA","fallback","getObject","objectID","attrs","i","getObjects","objectIDs","attributesToRetrieve","isArray","map","requests","prepareRequest","request","join"],"mappings":"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","sourcesContent":["var buildSearchMethod = require('./buildSearchMethod.js');\nvar deprecate = require('./deprecate.js');\nvar deprecatedMessage = require('./deprecatedMessage.js');\n\nmodule.exports = IndexCore;\n\n/*\n* Index class constructor.\n* You should not use this method directly but use initIndex() function\n*/\nfunction IndexCore(algoliasearch, indexName) {\n  this.indexName = indexName;\n  this.as = algoliasearch;\n  this.typeAheadArgs = null;\n  this.typeAheadValueOption = null;\n\n  // make sure every index instance has it's own cache\n  this.cache = {};\n}\n\n/*\n* Clear all queries in cache\n*/\nIndexCore.prototype.clearCache = function() {\n  this.cache = {};\n};\n\n/*\n* Search inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the full text query\n* @param {object} [args] (optional) if set, contains an object with query parameters:\n* - page: (integer) Pagination parameter used to select the page to retrieve.\n*                   Page is zero-based and defaults to 0. Thus,\n*                   to retrieve the 10th page you need to set page=9\n* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.\n* - attributesToRetrieve: a string that contains the list of object attributes\n* you want to retrieve (let you minimize the answer size).\n*   Attributes are separated with a comma (for example \"name,address\").\n*   You can also use an array (for example [\"name\",\"address\"]).\n*   By default, all attributes are retrieved. You can also use '*' to retrieve all\n*   values when an attributesToRetrieve setting is specified for your index.\n* - attributesToHighlight: a string that contains the list of attributes you\n*   want to highlight according to the query.\n*   Attributes are separated by a comma. You can also use an array (for example [\"name\",\"address\"]).\n*   If an attribute has no match for the query, the raw value is returned.\n*   By default all indexed text attributes are highlighted.\n*   You can use `*` if you want to highlight all textual attributes.\n*   Numerical attributes are not highlighted.\n*   A matchLevel is returned for each highlighted attribute and can contain:\n*      - full: if all the query terms were found in the attribute,\n*      - partial: if only some of the query terms were found,\n*      - none: if none of the query terms were found.\n* - attributesToSnippet: a string that contains the list of attributes to snippet alongside\n* the number of words to return (syntax is `attributeName:nbWords`).\n*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).\n*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).\n*    By default no snippet is computed.\n* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.\n* Defaults to 3.\n* - minWordSizefor2Typos: the minimum number of characters in a query word\n* to accept two typos in this word. Defaults to 7.\n* - getRankingInfo: if set to 1, the result hits will contain ranking\n* information in _rankingInfo attribute.\n* - aroundLatLng: search for entries around a given\n* latitude/longitude (specified as two floats separated by a comma).\n*   For example aroundLatLng=47.316669,5.016670).\n*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)\n*   and the precision for ranking with aroundPrecision\n*   (for example if you set aroundPrecision=100, two objects that are distant of\n*   less than 100m will be considered as identical for \"geo\" ranking parameter).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - insideBoundingBox: search entries inside a given area defined by the two extreme points\n* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).\n*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - numericFilters: a string that contains the list of numeric filters you want to\n* apply separated by a comma.\n*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.\n*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.\n*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.\n*   You can also use an array (for example numericFilters: [\"price>100\",\"price<1000\"]).\n* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.\n*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).\n*   You can also use an array, for example tagFilters: [\"tag1\",[\"tag2\",\"tag3\"]]\n*   means tag1 AND (tag2 OR tag3).\n*   At indexing, tags should be added in the _tags** attribute\n*   of objects (for example {\"_tags\":[\"tag1\",\"tag2\"]}).\n* - facetFilters: filter the query by a list of facets.\n*   Facets are separated by commas and each facet is encoded as `attributeName:value`.\n*   For example: `facetFilters=category:Book,author:John%20Doe`.\n*   You can also use an array (for example `[\"category:Book\",\"author:John%20Doe\"]`).\n* - facets: List of object attributes that you want to use for faceting.\n*   Comma separated list: `\"category,author\"` or array `['category','author']`\n*   Only attributes that have been added in **attributesForFaceting** index setting\n*   can be used in this parameter.\n*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.\n* - queryType: select how the query words are interpreted, it can be one of the following value:\n*    - prefixAll: all query words are interpreted as prefixes,\n*    - prefixLast: only the last word is interpreted as a prefix (default behavior),\n*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.\n* - optionalWords: a string that contains the list of words that should\n* be considered as optional when found in the query.\n*   Comma separated and array are accepted.\n* - distinct: If set to 1, enable the distinct feature (disabled by default)\n* if the attributeForDistinct index setting is set.\n*   This feature is similar to the SQL \"distinct\" keyword: when enabled\n*   in a query with the distinct=1 parameter,\n*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.\n*   For example, if the chosen attribute is show_name and several hits have\n*   the same value for show_name, then only the best\n*   one is kept and others are removed.\n* - restrictSearchableAttributes: List of attributes you want to use for\n* textual search (must be a subset of the attributesToIndex index setting)\n* either comma separated or as an array\n* @param {function} [callback] the result callback called with two arguments:\n*  error: null or Error('message'). If false, the content contains the error.\n*  content: the server answer that contains the list of results.\n*/\nIndexCore.prototype.search = buildSearchMethod('query');\n\n/*\n* -- BETA --\n* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the similar query\n* @param {object} [args] (optional) if set, contains an object with query parameters.\n*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters\n*   are the two most useful to restrict the similar results and get more relevant content\n*/\nIndexCore.prototype.similarSearch = deprecate(\n  buildSearchMethod('similarQuery'),\n  deprecatedMessage(\n    'index.similarSearch(query[, callback])',\n    'index.search({ similarQuery: query }[, callback])'\n  )\n);\n\n/*\n* Browse index content. The response content will have a `cursor` property that you can use\n* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browse('cool songs', {\n*   tagFilters: 'public,comments',\n*   hitsPerPage: 500\n* }, callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\nIndexCore.prototype.browse = function(query, queryParameters, callback) {\n  var merge = require('./merge.js');\n\n  var indexObj = this;\n\n  var page;\n  var hitsPerPage;\n\n  // we check variadic calls that are not the one defined\n  // .browse()/.browse(fn)\n  // => page = 0\n  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {\n    page = 0;\n    callback = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'number') {\n    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)\n    page = arguments[0];\n    if (typeof arguments[1] === 'number') {\n      hitsPerPage = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n      hitsPerPage = undefined;\n    }\n    query = undefined;\n    queryParameters = undefined;\n  } else if (typeof arguments[0] === 'object') {\n    // .browse(queryParameters)/.browse(queryParameters, cb)\n    if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n    }\n    queryParameters = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {\n    // .browse(query, cb)\n    callback = arguments[1];\n    queryParameters = undefined;\n  }\n\n  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)\n\n  // get search query parameters combining various possible calls\n  // to .browse();\n  queryParameters = merge({}, queryParameters || {}, {\n    page: page,\n    hitsPerPage: hitsPerPage,\n    query: query\n  });\n\n  var params = this.as._getSearchParams(queryParameters, '');\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',\n    body: {params: params},\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browseFrom('14lkfsakl32', callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\nIndexCore.prototype.browseFrom = function(cursor, callback) {\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',\n    body: {cursor: cursor},\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n*\n* @param {string} params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} params.facetQuery Query for the facet search\n* @param {string} [params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n* @param callback (optional)\n*/\nIndexCore.prototype.searchForFacetValues = function(params, callback) {\n  var clone = require('./clone.js');\n  var omit = require('./omit.js');\n  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';\n\n  if (params.facetName === undefined || params.facetQuery === undefined) {\n    throw new Error(usage);\n  }\n\n  var facetName = params.facetName;\n  var filteredParams = omit(clone(params), function(keyName) {\n    return keyName === 'facetName';\n  });\n  var searchParameters = this.as._getSearchParams(filteredParams, '');\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' +\n      encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',\n    hostType: 'read',\n    body: {params: searchParameters},\n    callback: callback\n  });\n};\n\nIndexCore.prototype.searchFacet = deprecate(function(params, callback) {\n  return this.searchForFacetValues(params, callback);\n}, deprecatedMessage(\n  'index.searchFacet(params[, callback])',\n  'index.searchForFacetValues(params[, callback])'\n));\n\nIndexCore.prototype._search = function(params, url, callback, additionalUA) {\n  return this.as._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',\n    body: {params: params},\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/' + encodeURIComponent(this.indexName),\n      body: {params: params}\n    },\n    callback: callback,\n    additionalUA: additionalUA\n  });\n};\n\n/*\n* Get an object from this index\n*\n* @param objectID the unique identifier of the object to retrieve\n* @param attrs (optional) if set, contains the array of attribute names to retrieve\n* @param callback (optional) the result callback called with two arguments\n*  error: null or Error('message')\n*  content: the object to retrieve or the error message if a failure occurred\n*/\nIndexCore.prototype.getObject = function(objectID, attrs, callback) {\n  var indexObj = this;\n\n  if (arguments.length === 1 || typeof attrs === 'function') {\n    callback = attrs;\n    attrs = undefined;\n  }\n\n  var params = '';\n  if (attrs !== undefined) {\n    params = '?attributes=';\n    for (var i = 0; i < attrs.length; ++i) {\n      if (i !== 0) {\n        params += ',';\n      }\n      params += attrs[i];\n    }\n  }\n\n  return this.as._jsonRequest({\n    method: 'GET',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Get several objects from this index\n*\n* @param objectIDs the array of unique identifier of objects to retrieve\n*/\nIndexCore.prototype.getObjects = function(objectIDs, attributesToRetrieve, callback) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';\n\n  if (!isArray(objectIDs)) {\n    throw new Error(usage);\n  }\n\n  var indexObj = this;\n\n  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {\n    callback = attributesToRetrieve;\n    attributesToRetrieve = undefined;\n  }\n\n  var body = {\n    requests: map(objectIDs, function prepareRequest(objectID) {\n      var request = {\n        indexName: indexObj.indexName,\n        objectID: objectID\n      };\n\n      if (attributesToRetrieve) {\n        request.attributesToRetrieve = attributesToRetrieve.join(',');\n      }\n\n      return request;\n    })\n  };\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/*/objects',\n    hostType: 'read',\n    body: body,\n    callback: callback\n  });\n};\n\nIndexCore.prototype.as = null;\nIndexCore.prototype.indexName = null;\nIndexCore.prototype.typeAheadArgs = null;\nIndexCore.prototype.typeAheadValueOption = null;\n"]},"metadata":{},"sourceType":"script"}