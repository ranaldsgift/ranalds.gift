{"ast":null,"code":"module.exports = AlgoliaSearchCore;\n\nvar errors = require('./errors');\n\nvar exitPromise = require('./exitPromise.js');\n\nvar IndexCore = require('./IndexCore.js');\n\nvar store = require('./store.js'); // We will always put the API KEY in the JSON body in case of too long API KEY,\n// to avoid query string being too long and failing in various conditions (our server limit, browser limit,\n// proxies limit)\n\n\nvar MAX_API_KEY_LENGTH = 500;\nvar RESET_APP_DATA_TIMER = process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) || 60 * 2 * 1000; // after 2 minutes reset to first host\n\n/*\n * Algolia Search library initialization\n * https://www.algolia.com/\n *\n * @param {string} applicationID - Your applicationID, found in your dashboard\n * @param {string} apiKey - Your API key, found in your dashboard\n * @param {Object} [opts]\n * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,\n * another request will be issued after this timeout\n * @param {string} [opts.protocol='https:'] - The protocol used to query Algolia Search API.\n *                                        Set to 'http:' to force using http.\n * @param {Object|Array} [opts.hosts={\n *           read: [this.applicationID + '-dsn.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]),\n *           write: [this.applicationID + '.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]) - The hosts to use for Algolia Search API.\n *           If you provide them, you will less benefit from our HA implementation\n */\n\nfunction AlgoliaSearchCore(applicationID, apiKey, opts) {\n  var debug = require('debug')('algoliasearch');\n\n  var clone = require('./clone.js');\n\n  var isArray = require('isarray');\n\n  var map = require('./map.js');\n\n  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';\n\n  if (opts._allowEmptyCredentials !== true && !applicationID) {\n    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);\n  }\n\n  if (opts._allowEmptyCredentials !== true && !apiKey) {\n    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);\n  }\n\n  this.applicationID = applicationID;\n  this.apiKey = apiKey;\n  this.hosts = {\n    read: [],\n    write: []\n  };\n  opts = opts || {};\n  this._timeouts = opts.timeouts || {\n    connect: 1 * 1000,\n    // 500ms connect is GPRS latency\n    read: 2 * 1000,\n    write: 30 * 1000\n  }; // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before\n\n  if (opts.timeout) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;\n  }\n\n  var protocol = opts.protocol || 'https:'; // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`\n  // we also accept `http` and `https`. It's a common error.\n\n  if (!/:$/.test(protocol)) {\n    protocol = protocol + ':';\n  }\n\n  if (protocol !== 'http:' && protocol !== 'https:') {\n    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');\n  }\n\n  this._checkAppIdData();\n\n  if (!opts.hosts) {\n    var defaultHosts = map(this._shuffleResult, function (hostNumber) {\n      return applicationID + '-' + hostNumber + '.algolianet.com';\n    }); // no hosts given, compute defaults\n\n    var mainSuffix = (opts.dsn === false ? '' : '-dsn') + '.algolia.net';\n    this.hosts.read = [this.applicationID + mainSuffix].concat(defaultHosts);\n    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);\n  } else if (isArray(opts.hosts)) {\n    // when passing custom hosts, we need to have a different host index if the number\n    // of write/read hosts are different.\n    this.hosts.read = clone(opts.hosts);\n    this.hosts.write = clone(opts.hosts);\n  } else {\n    this.hosts.read = clone(opts.hosts.read);\n    this.hosts.write = clone(opts.hosts.write);\n  } // add protocol and lowercase hosts\n\n\n  this.hosts.read = map(this.hosts.read, prepareHost(protocol));\n  this.hosts.write = map(this.hosts.write, prepareHost(protocol));\n  this.extraHeaders = {}; // In some situations you might want to warm the cache\n\n  this.cache = opts._cache || {};\n  this._ua = opts._ua;\n  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;\n  this._useRequestCache = this._useCache && opts._useRequestCache;\n  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;\n  this._setTimeout = opts._setTimeout;\n  debug('init done, %j', this);\n}\n/*\n * Get the index object initialized\n *\n * @param indexName the name of index\n * @param callback the result callback with one argument (the Index instance)\n */\n\n\nAlgoliaSearchCore.prototype.initIndex = function (indexName) {\n  return new IndexCore(this, indexName);\n};\n/**\n* Add an extra field to the HTTP request\n*\n* @param name the header field name\n* @param value the header field value\n*/\n\n\nAlgoliaSearchCore.prototype.setExtraHeader = function (name, value) {\n  this.extraHeaders[name.toLowerCase()] = value;\n};\n/**\n* Get the value of an extra HTTP header\n*\n* @param name the header field name\n*/\n\n\nAlgoliaSearchCore.prototype.getExtraHeader = function (name) {\n  return this.extraHeaders[name.toLowerCase()];\n};\n/**\n* Remove an extra field from the HTTP request\n*\n* @param name the header field name\n*/\n\n\nAlgoliaSearchCore.prototype.unsetExtraHeader = function (name) {\n  delete this.extraHeaders[name.toLowerCase()];\n};\n/**\n* Augment sent x-algolia-agent with more data, each agent part\n* is automatically separated from the others by a semicolon;\n*\n* @param algoliaAgent the agent to add\n*/\n\n\nAlgoliaSearchCore.prototype.addAlgoliaAgent = function (algoliaAgent) {\n  var algoliaAgentWithDelimiter = '; ' + algoliaAgent;\n\n  if (this._ua.indexOf(algoliaAgentWithDelimiter) === -1) {\n    this._ua += algoliaAgentWithDelimiter;\n  }\n};\n/*\n * Wrapper that try all hosts to maximize the quality of service\n */\n\n\nAlgoliaSearchCore.prototype._jsonRequest = function (initialOpts) {\n  this._checkAppIdData();\n\n  var requestDebug = require('debug')('algoliasearch:' + initialOpts.url);\n\n  var body;\n  var cacheID;\n  var additionalUA = initialOpts.additionalUA || '';\n  var cache = initialOpts.cache;\n  var client = this;\n  var tries = 0;\n  var usingFallback = false;\n  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;\n  var headers;\n\n  if (this.apiKey.length > MAX_API_KEY_LENGTH && initialOpts.body !== undefined && (initialOpts.body.params !== undefined || // index.search()\n  initialOpts.body.requests !== undefined) // client.search()\n  ) {\n      initialOpts.body.apiKey = this.apiKey;\n      headers = this._computeRequestHeaders({\n        additionalUA: additionalUA,\n        withApiKey: false,\n        headers: initialOpts.headers\n      });\n    } else {\n    headers = this._computeRequestHeaders({\n      additionalUA: additionalUA,\n      headers: initialOpts.headers\n    });\n  }\n\n  if (initialOpts.body !== undefined) {\n    body = safeJSONStringify(initialOpts.body);\n  }\n\n  requestDebug('request start');\n  var debugData = [];\n\n  function doRequest(requester, reqOpts) {\n    client._checkAppIdData();\n\n    var startTime = new Date();\n\n    if (client._useCache && !client._useRequestCache) {\n      cacheID = initialOpts.url;\n    } // as we sometime use POST requests to pass parameters (like query='aa'),\n    // the cacheID must also include the body to be different between calls\n\n\n    if (client._useCache && !client._useRequestCache && body) {\n      cacheID += '_body_' + reqOpts.body;\n    } // handle cache existence\n\n\n    if (isCacheValidWithCurrentID(!client._useRequestCache, cache, cacheID)) {\n      requestDebug('serving response from cache');\n      var responseText = cache[cacheID]; // Cache response must match the type of the original one\n\n      return client._promise.resolve({\n        body: JSON.parse(responseText),\n        responseText: responseText\n      });\n    } // if we reached max tries\n\n\n    if (tries >= client.hosts[initialOpts.hostType].length) {\n      if (!hasFallback || usingFallback) {\n        requestDebug('could not get any response'); // then stop\n\n        return client._promise.reject(new errors.AlgoliaSearchError('Cannot connect to the AlgoliaSearch API.' + ' Send an email to support@algolia.com to report and resolve the issue.' + ' Application id was: ' + client.applicationID, {\n          debugData: debugData\n        }));\n      }\n\n      requestDebug('switching to fallback'); // let's try the fallback starting from here\n\n      tries = 0; // method, url and body are fallback dependent\n\n      reqOpts.method = initialOpts.fallback.method;\n      reqOpts.url = initialOpts.fallback.url;\n      reqOpts.jsonBody = initialOpts.fallback.body;\n\n      if (reqOpts.jsonBody) {\n        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);\n      } // re-compute headers, they could be omitting the API KEY\n\n\n      headers = client._computeRequestHeaders({\n        additionalUA: additionalUA,\n        headers: initialOpts.headers\n      });\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n\n      client._setHostIndexByType(0, initialOpts.hostType);\n\n      usingFallback = true; // the current request is now using fallback\n\n      return doRequest(client._request.fallback, reqOpts);\n    }\n\n    var currentHost = client._getHostByType(initialOpts.hostType);\n\n    var url = currentHost + reqOpts.url;\n    var options = {\n      body: reqOpts.body,\n      jsonBody: reqOpts.jsonBody,\n      method: reqOpts.method,\n      headers: headers,\n      timeouts: reqOpts.timeouts,\n      debug: requestDebug,\n      forceAuthHeaders: reqOpts.forceAuthHeaders\n    };\n    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d', options.method, url, options.headers, options.timeouts);\n\n    if (requester === client._request.fallback) {\n      requestDebug('using fallback');\n    } // `requester` is any of this._request or this._request.fallback\n    // thus it needs to be called using the client as context\n\n\n    return requester.call(client, url, options).then(success, tryFallback);\n\n    function success(httpResponse) {\n      // compute the status of the response,\n      //\n      // When in browser mode, using XDR or JSONP, we have no statusCode available\n      // So we rely on our API response `status` property.\n      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)\n      // So we check if there's a `message` along `status` and it means it's an error\n      //\n      // That's the only case where we have a response.status that's not the http statusCode\n      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status || // this is important to check the request statusCode AFTER the body eventual\n      // statusCode because some implementations (jQuery XDomainRequest transport) may\n      // send statusCode 200 while we had an error\n      httpResponse.statusCode || // When in browser mode, using XDR or JSONP\n      // we default to success when no error (no response.status && response.message)\n      // If there was a JSON.parse() error then body is null and it fails\n      httpResponse && httpResponse.body && 200;\n      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j', httpResponse.statusCode, status, httpResponse.headers);\n      var httpResponseOk = Math.floor(status / 100) === 2;\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime,\n        statusCode: status\n      });\n\n      if (httpResponseOk) {\n        if (client._useCache && !client._useRequestCache && cache) {\n          cache[cacheID] = httpResponse.responseText;\n        }\n\n        return {\n          responseText: httpResponse.responseText,\n          body: httpResponse.body\n        };\n      }\n\n      var shouldRetry = Math.floor(status / 100) !== 4;\n\n      if (shouldRetry) {\n        tries += 1;\n        return retryRequest();\n      }\n\n      requestDebug('unrecoverable error'); // no success and no retry => fail\n\n      var unrecoverableError = new errors.AlgoliaSearchError(httpResponse.body && httpResponse.body.message, {\n        debugData: debugData,\n        statusCode: status\n      });\n      return client._promise.reject(unrecoverableError);\n    }\n\n    function tryFallback(err) {\n      // error cases:\n      //  While not in fallback mode:\n      //    - CORS not supported\n      //    - network error\n      //  While in fallback mode:\n      //    - timeout\n      //    - network error\n      //    - badly formatted JSONP (script loaded, did not call our callback)\n      //  In both cases:\n      //    - uncaught exception occurs (TypeError)\n      requestDebug('error: %s, stack: %s', err.message, err.stack);\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime\n      });\n\n      if (!(err instanceof errors.AlgoliaSearchError)) {\n        err = new errors.Unknown(err && err.message, err);\n      }\n\n      tries += 1; // stop the request implementation when:\n\n      if ( // we did not generate this error,\n      // it comes from a throw in some other piece of code\n      err instanceof errors.Unknown || // server sent unparsable JSON\n      err instanceof errors.UnparsableJSON || // max tries and already using fallback or no fallback\n      tries >= client.hosts[initialOpts.hostType].length && (usingFallback || !hasFallback)) {\n        // stop request implementation for this command\n        err.debugData = debugData;\n        return client._promise.reject(err);\n      } // When a timeout occurred, retry by raising timeout\n\n\n      if (err instanceof errors.RequestTimeout) {\n        return retryRequestWithHigherTimeout();\n      }\n\n      return retryRequest();\n    }\n\n    function retryRequest() {\n      requestDebug('retrying request');\n\n      client._incrementHostIndex(initialOpts.hostType);\n\n      return doRequest(requester, reqOpts);\n    }\n\n    function retryRequestWithHigherTimeout() {\n      requestDebug('retrying request with higher timeout');\n\n      client._incrementHostIndex(initialOpts.hostType);\n\n      client._incrementTimeoutMultipler();\n\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n      return doRequest(requester, reqOpts);\n    }\n  }\n\n  function isCacheValidWithCurrentID(useRequestCache, currentCache, currentCacheID) {\n    return client._useCache && useRequestCache && currentCache && currentCache[currentCacheID] !== undefined;\n  }\n\n  function interopCallbackReturn(request, callback) {\n    if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n      request.catch(function () {\n        // Release the cache on error\n        delete cache[cacheID];\n      });\n    }\n\n    if (typeof initialOpts.callback === 'function') {\n      // either we have a callback\n      request.then(function okCb(content) {\n        exitPromise(function () {\n          initialOpts.callback(null, callback(content));\n        }, client._setTimeout || setTimeout);\n      }, function nookCb(err) {\n        exitPromise(function () {\n          initialOpts.callback(err);\n        }, client._setTimeout || setTimeout);\n      });\n    } else {\n      // either we are using promises\n      return request.then(callback);\n    }\n  }\n\n  if (client._useCache && client._useRequestCache) {\n    cacheID = initialOpts.url;\n  } // as we sometime use POST requests to pass parameters (like query='aa'),\n  // the cacheID must also include the body to be different between calls\n\n\n  if (client._useCache && client._useRequestCache && body) {\n    cacheID += '_body_' + body;\n  }\n\n  if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n    requestDebug('serving request from cache');\n    var maybePromiseForCache = cache[cacheID]; // In case the cache is warmup with value that is not a promise\n\n    var promiseForCache = typeof maybePromiseForCache.then !== 'function' ? client._promise.resolve({\n      responseText: maybePromiseForCache\n    }) : maybePromiseForCache;\n    return interopCallbackReturn(promiseForCache, function (content) {\n      // In case of the cache request, return the original value\n      return JSON.parse(content.responseText);\n    });\n  }\n\n  var request = doRequest(client._request, {\n    url: initialOpts.url,\n    method: initialOpts.method,\n    body: body,\n    jsonBody: initialOpts.body,\n    timeouts: client._getTimeoutsForRequest(initialOpts.hostType),\n    forceAuthHeaders: initialOpts.forceAuthHeaders\n  });\n\n  if (client._useCache && client._useRequestCache && cache) {\n    cache[cacheID] = request;\n  }\n\n  return interopCallbackReturn(request, function (content) {\n    // In case of the first request, return the JSON value\n    return content.body;\n  });\n};\n/*\n* Transform search param object in query string\n* @param {object} args arguments to add to the current query string\n* @param {string} params current query string\n* @return {string} the final query string\n*/\n\n\nAlgoliaSearchCore.prototype._getSearchParams = function (args, params) {\n  if (args === undefined || args === null) {\n    return params;\n  }\n\n  for (var key in args) {\n    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {\n      params += params === '' ? '' : '&';\n      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);\n    }\n  }\n\n  return params;\n};\n/**\n * Compute the headers for a request\n *\n * @param [string] options.additionalUA semi-colon separated string with other user agents to add\n * @param [boolean=true] options.withApiKey Send the api key as a header\n * @param [Object] options.headers Extra headers to send\n */\n\n\nAlgoliaSearchCore.prototype._computeRequestHeaders = function (options) {\n  var forEach = require('foreach');\n\n  var ua = options.additionalUA ? this._ua + '; ' + options.additionalUA : this._ua;\n  var requestHeaders = {\n    'x-algolia-agent': ua,\n    'x-algolia-application-id': this.applicationID\n  }; // browser will inline headers in the url, node.js will use http headers\n  // but in some situations, the API KEY will be too long (big secured API keys)\n  // so if the request is a POST and the KEY is very long, we will be asked to not put\n  // it into headers but in the JSON body\n\n  if (options.withApiKey !== false) {\n    requestHeaders['x-algolia-api-key'] = this.apiKey;\n  }\n\n  if (this.userToken) {\n    requestHeaders['x-algolia-usertoken'] = this.userToken;\n  }\n\n  if (this.securityTags) {\n    requestHeaders['x-algolia-tagfilters'] = this.securityTags;\n  }\n\n  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {\n    requestHeaders[key] = value;\n  });\n\n  if (options.headers) {\n    forEach(options.headers, function addToRequestHeaders(value, key) {\n      requestHeaders[key] = value;\n    });\n  }\n\n  return requestHeaders;\n};\n/**\n * Search through multiple indices at the same time\n * @param  {Object[]}   queries  An array of queries you want to run.\n * @param {string} queries[].indexName The index name you want to target\n * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`\n * @param {Object} queries[].params Any search param like hitsPerPage, ..\n * @param  {Function} callback Callback to be called\n * @return {Promise|undefined} Returns a promise if no callback given\n */\n\n\nAlgoliaSearchCore.prototype.search = function (queries, opts, callback) {\n  var isArray = require('isarray');\n\n  var map = require('./map.js');\n\n  var usage = 'Usage: client.search(arrayOfQueries[, callback])';\n\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  } else if (opts === undefined) {\n    opts = {};\n  }\n\n  var client = this;\n  var postObj = {\n    requests: map(queries, function prepareRequest(query) {\n      var params = ''; // allow query.query\n      // so we are mimicing the index.search(query, params) method\n      // {indexName:, query:, params:}\n\n      if (query.query !== undefined) {\n        params += 'query=' + encodeURIComponent(query.query);\n      }\n\n      return {\n        indexName: query.indexName,\n        params: client._getSearchParams(query.params, params)\n      };\n    })\n  };\n  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {\n    return requestId + '=' + encodeURIComponent('/1/indexes/' + encodeURIComponent(request.indexName) + '?' + request.params);\n  }).join('&');\n  var url = '/1/indexes/*/queries';\n\n  if (opts.strategy !== undefined) {\n    postObj.strategy = opts.strategy;\n  }\n\n  return this._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url,\n    body: postObj,\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/*',\n      body: {\n        params: JSONPParams\n      }\n    },\n    callback: callback\n  });\n};\n/**\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n* This is the top-level API for SFFV.\n*\n* @param {object[]} queries An array of queries to run.\n* @param {string} queries[].indexName Index name, name of the index to search.\n* @param {object} queries[].params Query parameters.\n* @param {string} queries[].params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} queries[].params.facetQuery Query for the facet search\n* @param {string} [queries[].params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n*/\n\n\nAlgoliaSearchCore.prototype.searchForFacetValues = function (queries) {\n  var isArray = require('isarray');\n\n  var map = require('./map.js');\n\n  var usage = 'Usage: client.searchForFacetValues([{indexName, params: {facetName, facetQuery, ...params}}, ...queries])'; // eslint-disable-line max-len\n\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n\n  var client = this;\n  return client._promise.all(map(queries, function performQuery(query) {\n    if (!query || query.indexName === undefined || query.params.facetName === undefined || query.params.facetQuery === undefined) {\n      throw new Error(usage);\n    }\n\n    var clone = require('./clone.js');\n\n    var omit = require('./omit.js');\n\n    var indexName = query.indexName;\n    var params = query.params;\n    var facetName = params.facetName;\n    var filteredParams = omit(clone(params), function (keyName) {\n      return keyName === 'facetName';\n    });\n\n    var searchParameters = client._getSearchParams(filteredParams, '');\n\n    return client._jsonRequest({\n      cache: client.cache,\n      method: 'POST',\n      url: '/1/indexes/' + encodeURIComponent(indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',\n      hostType: 'read',\n      body: {\n        params: searchParameters\n      }\n    });\n  }));\n};\n/**\n * Set the extra security tagFilters header\n * @param {string|array} tags The list of tags defining the current security filters\n */\n\n\nAlgoliaSearchCore.prototype.setSecurityTags = function (tags) {\n  if (Object.prototype.toString.call(tags) === '[object Array]') {\n    var strTags = [];\n\n    for (var i = 0; i < tags.length; ++i) {\n      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {\n        var oredTags = [];\n\n        for (var j = 0; j < tags[i].length; ++j) {\n          oredTags.push(tags[i][j]);\n        }\n\n        strTags.push('(' + oredTags.join(',') + ')');\n      } else {\n        strTags.push(tags[i]);\n      }\n    }\n\n    tags = strTags.join(',');\n  }\n\n  this.securityTags = tags;\n};\n/**\n * Set the extra user token header\n * @param {string} userToken The token identifying a uniq user (used to apply rate limits)\n */\n\n\nAlgoliaSearchCore.prototype.setUserToken = function (userToken) {\n  this.userToken = userToken;\n};\n/**\n * Clear all queries in client's cache\n * @return undefined\n */\n\n\nAlgoliaSearchCore.prototype.clearCache = function () {\n  this.cache = {};\n};\n/**\n* Set the number of milliseconds a request can take before automatically being terminated.\n* @deprecated\n* @param {Number} milliseconds\n*/\n\n\nAlgoliaSearchCore.prototype.setRequestTimeout = function (milliseconds) {\n  if (milliseconds) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;\n  }\n};\n/**\n* Set the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\n\n\nAlgoliaSearchCore.prototype.setTimeouts = function (timeouts) {\n  this._timeouts = timeouts;\n};\n/**\n* Get the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\n\n\nAlgoliaSearchCore.prototype.getTimeouts = function () {\n  return this._timeouts;\n};\n\nAlgoliaSearchCore.prototype._getAppIdData = function () {\n  var data = store.get(this.applicationID);\n  if (data !== null) this._cacheAppIdData(data);\n  return data;\n};\n\nAlgoliaSearchCore.prototype._setAppIdData = function (data) {\n  data.lastChange = new Date().getTime();\n\n  this._cacheAppIdData(data);\n\n  return store.set(this.applicationID, data);\n};\n\nAlgoliaSearchCore.prototype._checkAppIdData = function () {\n  var data = this._getAppIdData();\n\n  var now = new Date().getTime();\n\n  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {\n    return this._resetInitialAppIdData(data);\n  }\n\n  return data;\n};\n\nAlgoliaSearchCore.prototype._resetInitialAppIdData = function (data) {\n  var newData = data || {};\n  newData.hostIndexes = {\n    read: 0,\n    write: 0\n  };\n  newData.timeoutMultiplier = 1;\n  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);\n  return this._setAppIdData(newData);\n};\n\nAlgoliaSearchCore.prototype._cacheAppIdData = function (data) {\n  this._hostIndexes = data.hostIndexes;\n  this._timeoutMultiplier = data.timeoutMultiplier;\n  this._shuffleResult = data.shuffleResult;\n};\n\nAlgoliaSearchCore.prototype._partialAppIdDataUpdate = function (newData) {\n  var foreach = require('foreach');\n\n  var currentData = this._getAppIdData();\n\n  foreach(newData, function (value, key) {\n    currentData[key] = value;\n  });\n  return this._setAppIdData(currentData);\n};\n\nAlgoliaSearchCore.prototype._getHostByType = function (hostType) {\n  return this.hosts[hostType][this._getHostIndexByType(hostType)];\n};\n\nAlgoliaSearchCore.prototype._getTimeoutMultiplier = function () {\n  return this._timeoutMultiplier;\n};\n\nAlgoliaSearchCore.prototype._getHostIndexByType = function (hostType) {\n  return this._hostIndexes[hostType];\n};\n\nAlgoliaSearchCore.prototype._setHostIndexByType = function (hostIndex, hostType) {\n  var clone = require('./clone');\n\n  var newHostIndexes = clone(this._hostIndexes);\n  newHostIndexes[hostType] = hostIndex;\n\n  this._partialAppIdDataUpdate({\n    hostIndexes: newHostIndexes\n  });\n\n  return hostIndex;\n};\n\nAlgoliaSearchCore.prototype._incrementHostIndex = function (hostType) {\n  return this._setHostIndexByType((this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType);\n};\n\nAlgoliaSearchCore.prototype._incrementTimeoutMultipler = function () {\n  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);\n  return this._partialAppIdDataUpdate({\n    timeoutMultiplier: timeoutMultiplier\n  });\n};\n\nAlgoliaSearchCore.prototype._getTimeoutsForRequest = function (hostType) {\n  return {\n    connect: this._timeouts.connect * this._timeoutMultiplier,\n    complete: this._timeouts[hostType] * this._timeoutMultiplier\n  };\n};\n\nfunction prepareHost(protocol) {\n  return function prepare(host) {\n    return protocol + '//' + host.toLowerCase();\n  };\n} // Prototype.js < 1.7, a widely used library, defines a weird\n// Array.prototype.toJSON function that will fail to stringify our content\n// appropriately\n// refs:\n//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q\n//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c\n//   - http://stackoverflow.com/a/3148441/147079\n\n\nfunction safeJSONStringify(obj) {\n  /* eslint no-extend-native:0 */\n  if (Array.prototype.toJSON === undefined) {\n    return JSON.stringify(obj);\n  }\n\n  var toJSON = Array.prototype.toJSON;\n  delete Array.prototype.toJSON;\n  var out = JSON.stringify(obj);\n  Array.prototype.toJSON = toJSON;\n  return out;\n}\n\nfunction shuffle(array) {\n  var currentIndex = array.length;\n  var temporaryValue;\n  var randomIndex; // While there remain elements to shuffle...\n\n  while (currentIndex !== 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1; // And swap it with the current element.\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nfunction removeCredentials(headers) {\n  var newHeaders = {};\n\n  for (var headerName in headers) {\n    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {\n      var value;\n\n      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {\n        value = '**hidden for security purposes**';\n      } else {\n        value = headers[headerName];\n      }\n\n      newHeaders[headerName] = value;\n    }\n  }\n\n  return newHeaders;\n}","map":{"version":3,"sources":["C:/dev/ranaldsgift/node_modules/algoliasearch/src/AlgoliaSearchCore.js"],"names":["module","exports","AlgoliaSearchCore","errors","require","exitPromise","IndexCore","store","MAX_API_KEY_LENGTH","RESET_APP_DATA_TIMER","process","env","parseInt","applicationID","apiKey","opts","debug","clone","isArray","map","usage","_allowEmptyCredentials","AlgoliaSearchError","hosts","read","write","_timeouts","timeouts","connect","timeout","protocol","test","_checkAppIdData","defaultHosts","_shuffleResult","hostNumber","mainSuffix","dsn","concat","prepareHost","extraHeaders","cache","_cache","_ua","_useCache","undefined","_useRequestCache","_useFallback","useFallback","_setTimeout","prototype","initIndex","indexName","setExtraHeader","name","value","toLowerCase","getExtraHeader","unsetExtraHeader","addAlgoliaAgent","algoliaAgent","algoliaAgentWithDelimiter","indexOf","_jsonRequest","initialOpts","requestDebug","url","body","cacheID","additionalUA","client","tries","usingFallback","hasFallback","_request","fallback","headers","length","params","requests","_computeRequestHeaders","withApiKey","safeJSONStringify","debugData","doRequest","requester","reqOpts","startTime","Date","isCacheValidWithCurrentID","responseText","_promise","resolve","JSON","parse","hostType","reject","method","jsonBody","_getTimeoutsForRequest","_setHostIndexByType","currentHost","_getHostByType","options","forceAuthHeaders","call","then","success","tryFallback","httpResponse","status","message","statusCode","httpResponseOk","Math","floor","endTime","push","removeCredentials","content","contentLength","duration","shouldRetry","retryRequest","unrecoverableError","err","stack","Unknown","UnparsableJSON","RequestTimeout","retryRequestWithHigherTimeout","_incrementHostIndex","_incrementTimeoutMultipler","useRequestCache","currentCache","currentCacheID","interopCallbackReturn","request","callback","catch","okCb","setTimeout","nookCb","maybePromiseForCache","promiseForCache","_getSearchParams","args","key","hasOwnProperty","encodeURIComponent","Object","toString","forEach","ua","requestHeaders","userToken","securityTags","addToRequestHeaders","search","queries","Error","postObj","prepareRequest","query","JSONPParams","prepareJSONPParams","requestId","join","strategy","searchForFacetValues","all","performQuery","facetName","facetQuery","omit","filteredParams","keyName","searchParameters","setSecurityTags","tags","strTags","i","oredTags","j","setUserToken","clearCache","setRequestTimeout","milliseconds","setTimeouts","getTimeouts","_getAppIdData","data","get","_cacheAppIdData","_setAppIdData","lastChange","getTime","set","now","_resetInitialAppIdData","newData","hostIndexes","timeoutMultiplier","shuffleResult","shuffle","_hostIndexes","_timeoutMultiplier","_partialAppIdDataUpdate","foreach","currentData","_getHostIndexByType","_getTimeoutMultiplier","hostIndex","newHostIndexes","max","complete","prepare","host","obj","Array","toJSON","stringify","out","array","currentIndex","temporaryValue","randomIndex","random","newHeaders","headerName"],"mappings":"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","sourcesContent":["module.exports = AlgoliaSearchCore;\n\nvar errors = require('./errors');\nvar exitPromise = require('./exitPromise.js');\nvar IndexCore = require('./IndexCore.js');\nvar store = require('./store.js');\n\n// We will always put the API KEY in the JSON body in case of too long API KEY,\n// to avoid query string being too long and failing in various conditions (our server limit, browser limit,\n// proxies limit)\nvar MAX_API_KEY_LENGTH = 500;\nvar RESET_APP_DATA_TIMER =\n  process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) ||\n  60 * 2 * 1000; // after 2 minutes reset to first host\n\n/*\n * Algolia Search library initialization\n * https://www.algolia.com/\n *\n * @param {string} applicationID - Your applicationID, found in your dashboard\n * @param {string} apiKey - Your API key, found in your dashboard\n * @param {Object} [opts]\n * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,\n * another request will be issued after this timeout\n * @param {string} [opts.protocol='https:'] - The protocol used to query Algolia Search API.\n *                                        Set to 'http:' to force using http.\n * @param {Object|Array} [opts.hosts={\n *           read: [this.applicationID + '-dsn.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]),\n *           write: [this.applicationID + '.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]) - The hosts to use for Algolia Search API.\n *           If you provide them, you will less benefit from our HA implementation\n */\nfunction AlgoliaSearchCore(applicationID, apiKey, opts) {\n  var debug = require('debug')('algoliasearch');\n\n  var clone = require('./clone.js');\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';\n\n  if (opts._allowEmptyCredentials !== true && !applicationID) {\n    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);\n  }\n\n  if (opts._allowEmptyCredentials !== true && !apiKey) {\n    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);\n  }\n\n  this.applicationID = applicationID;\n  this.apiKey = apiKey;\n\n  this.hosts = {\n    read: [],\n    write: []\n  };\n\n  opts = opts || {};\n\n  this._timeouts = opts.timeouts || {\n    connect: 1 * 1000, // 500ms connect is GPRS latency\n    read: 2 * 1000,\n    write: 30 * 1000\n  };\n\n  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before\n  if (opts.timeout) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;\n  }\n\n  var protocol = opts.protocol || 'https:';\n  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`\n  // we also accept `http` and `https`. It's a common error.\n  if (!/:$/.test(protocol)) {\n    protocol = protocol + ':';\n  }\n\n  if (protocol !== 'http:' && protocol !== 'https:') {\n    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');\n  }\n\n  this._checkAppIdData();\n\n  if (!opts.hosts) {\n    var defaultHosts = map(this._shuffleResult, function(hostNumber) {\n      return applicationID + '-' + hostNumber + '.algolianet.com';\n    });\n\n    // no hosts given, compute defaults\n    var mainSuffix = (opts.dsn === false ? '' : '-dsn') + '.algolia.net';\n    this.hosts.read = [this.applicationID + mainSuffix].concat(defaultHosts);\n    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);\n  } else if (isArray(opts.hosts)) {\n    // when passing custom hosts, we need to have a different host index if the number\n    // of write/read hosts are different.\n    this.hosts.read = clone(opts.hosts);\n    this.hosts.write = clone(opts.hosts);\n  } else {\n    this.hosts.read = clone(opts.hosts.read);\n    this.hosts.write = clone(opts.hosts.write);\n  }\n\n  // add protocol and lowercase hosts\n  this.hosts.read = map(this.hosts.read, prepareHost(protocol));\n  this.hosts.write = map(this.hosts.write, prepareHost(protocol));\n\n  this.extraHeaders = {};\n\n  // In some situations you might want to warm the cache\n  this.cache = opts._cache || {};\n\n  this._ua = opts._ua;\n  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;\n  this._useRequestCache = this._useCache && opts._useRequestCache;\n  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;\n\n  this._setTimeout = opts._setTimeout;\n\n  debug('init done, %j', this);\n}\n\n/*\n * Get the index object initialized\n *\n * @param indexName the name of index\n * @param callback the result callback with one argument (the Index instance)\n */\nAlgoliaSearchCore.prototype.initIndex = function(indexName) {\n  return new IndexCore(this, indexName);\n};\n\n/**\n* Add an extra field to the HTTP request\n*\n* @param name the header field name\n* @param value the header field value\n*/\nAlgoliaSearchCore.prototype.setExtraHeader = function(name, value) {\n  this.extraHeaders[name.toLowerCase()] = value;\n};\n\n/**\n* Get the value of an extra HTTP header\n*\n* @param name the header field name\n*/\nAlgoliaSearchCore.prototype.getExtraHeader = function(name) {\n  return this.extraHeaders[name.toLowerCase()];\n};\n\n/**\n* Remove an extra field from the HTTP request\n*\n* @param name the header field name\n*/\nAlgoliaSearchCore.prototype.unsetExtraHeader = function(name) {\n  delete this.extraHeaders[name.toLowerCase()];\n};\n\n/**\n* Augment sent x-algolia-agent with more data, each agent part\n* is automatically separated from the others by a semicolon;\n*\n* @param algoliaAgent the agent to add\n*/\nAlgoliaSearchCore.prototype.addAlgoliaAgent = function(algoliaAgent) {\n  var algoliaAgentWithDelimiter = '; ' + algoliaAgent;\n\n  if (this._ua.indexOf(algoliaAgentWithDelimiter) === -1) {\n    this._ua += algoliaAgentWithDelimiter;\n  }\n};\n\n/*\n * Wrapper that try all hosts to maximize the quality of service\n */\nAlgoliaSearchCore.prototype._jsonRequest = function(initialOpts) {\n  this._checkAppIdData();\n\n  var requestDebug = require('debug')('algoliasearch:' + initialOpts.url);\n\n\n  var body;\n  var cacheID;\n  var additionalUA = initialOpts.additionalUA || '';\n  var cache = initialOpts.cache;\n  var client = this;\n  var tries = 0;\n  var usingFallback = false;\n  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;\n  var headers;\n\n  if (\n    this.apiKey.length > MAX_API_KEY_LENGTH &&\n    initialOpts.body !== undefined &&\n    (initialOpts.body.params !== undefined || // index.search()\n    initialOpts.body.requests !== undefined) // client.search()\n  ) {\n    initialOpts.body.apiKey = this.apiKey;\n    headers = this._computeRequestHeaders({\n      additionalUA: additionalUA,\n      withApiKey: false,\n      headers: initialOpts.headers\n    });\n  } else {\n    headers = this._computeRequestHeaders({\n      additionalUA: additionalUA,\n      headers: initialOpts.headers\n    });\n  }\n\n  if (initialOpts.body !== undefined) {\n    body = safeJSONStringify(initialOpts.body);\n  }\n\n  requestDebug('request start');\n  var debugData = [];\n\n\n  function doRequest(requester, reqOpts) {\n    client._checkAppIdData();\n\n    var startTime = new Date();\n\n    if (client._useCache && !client._useRequestCache) {\n      cacheID = initialOpts.url;\n    }\n\n    // as we sometime use POST requests to pass parameters (like query='aa'),\n    // the cacheID must also include the body to be different between calls\n    if (client._useCache && !client._useRequestCache && body) {\n      cacheID += '_body_' + reqOpts.body;\n    }\n\n    // handle cache existence\n    if (isCacheValidWithCurrentID(!client._useRequestCache, cache, cacheID)) {\n      requestDebug('serving response from cache');\n\n      var responseText = cache[cacheID];\n\n      // Cache response must match the type of the original one\n      return client._promise.resolve({\n        body: JSON.parse(responseText),\n        responseText: responseText\n      });\n    }\n\n    // if we reached max tries\n    if (tries >= client.hosts[initialOpts.hostType].length) {\n      if (!hasFallback || usingFallback) {\n        requestDebug('could not get any response');\n        // then stop\n        return client._promise.reject(new errors.AlgoliaSearchError(\n          'Cannot connect to the AlgoliaSearch API.' +\n          ' Send an email to support@algolia.com to report and resolve the issue.' +\n          ' Application id was: ' + client.applicationID, {debugData: debugData}\n        ));\n      }\n\n      requestDebug('switching to fallback');\n\n      // let's try the fallback starting from here\n      tries = 0;\n\n      // method, url and body are fallback dependent\n      reqOpts.method = initialOpts.fallback.method;\n      reqOpts.url = initialOpts.fallback.url;\n      reqOpts.jsonBody = initialOpts.fallback.body;\n      if (reqOpts.jsonBody) {\n        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);\n      }\n      // re-compute headers, they could be omitting the API KEY\n      headers = client._computeRequestHeaders({\n        additionalUA: additionalUA,\n        headers: initialOpts.headers\n      });\n\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n      client._setHostIndexByType(0, initialOpts.hostType);\n      usingFallback = true; // the current request is now using fallback\n      return doRequest(client._request.fallback, reqOpts);\n    }\n\n    var currentHost = client._getHostByType(initialOpts.hostType);\n\n    var url = currentHost + reqOpts.url;\n    var options = {\n      body: reqOpts.body,\n      jsonBody: reqOpts.jsonBody,\n      method: reqOpts.method,\n      headers: headers,\n      timeouts: reqOpts.timeouts,\n      debug: requestDebug,\n      forceAuthHeaders: reqOpts.forceAuthHeaders\n    };\n\n    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d',\n      options.method, url, options.headers, options.timeouts);\n\n    if (requester === client._request.fallback) {\n      requestDebug('using fallback');\n    }\n\n    // `requester` is any of this._request or this._request.fallback\n    // thus it needs to be called using the client as context\n    return requester.call(client, url, options).then(success, tryFallback);\n\n    function success(httpResponse) {\n      // compute the status of the response,\n      //\n      // When in browser mode, using XDR or JSONP, we have no statusCode available\n      // So we rely on our API response `status` property.\n      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)\n      // So we check if there's a `message` along `status` and it means it's an error\n      //\n      // That's the only case where we have a response.status that's not the http statusCode\n      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||\n\n        // this is important to check the request statusCode AFTER the body eventual\n        // statusCode because some implementations (jQuery XDomainRequest transport) may\n        // send statusCode 200 while we had an error\n        httpResponse.statusCode ||\n\n        // When in browser mode, using XDR or JSONP\n        // we default to success when no error (no response.status && response.message)\n        // If there was a JSON.parse() error then body is null and it fails\n        httpResponse && httpResponse.body && 200;\n\n      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j',\n        httpResponse.statusCode, status, httpResponse.headers);\n\n      var httpResponseOk = Math.floor(status / 100) === 2;\n\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime,\n        statusCode: status\n      });\n\n      if (httpResponseOk) {\n        if (client._useCache && !client._useRequestCache && cache) {\n          cache[cacheID] = httpResponse.responseText;\n        }\n\n        return {\n          responseText: httpResponse.responseText,\n          body: httpResponse.body\n        };\n      }\n\n      var shouldRetry = Math.floor(status / 100) !== 4;\n\n      if (shouldRetry) {\n        tries += 1;\n        return retryRequest();\n      }\n\n      requestDebug('unrecoverable error');\n\n      // no success and no retry => fail\n      var unrecoverableError = new errors.AlgoliaSearchError(\n        httpResponse.body && httpResponse.body.message, {debugData: debugData, statusCode: status}\n      );\n\n      return client._promise.reject(unrecoverableError);\n    }\n\n    function tryFallback(err) {\n      // error cases:\n      //  While not in fallback mode:\n      //    - CORS not supported\n      //    - network error\n      //  While in fallback mode:\n      //    - timeout\n      //    - network error\n      //    - badly formatted JSONP (script loaded, did not call our callback)\n      //  In both cases:\n      //    - uncaught exception occurs (TypeError)\n      requestDebug('error: %s, stack: %s', err.message, err.stack);\n\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime\n      });\n\n      if (!(err instanceof errors.AlgoliaSearchError)) {\n        err = new errors.Unknown(err && err.message, err);\n      }\n\n      tries += 1;\n\n      // stop the request implementation when:\n      if (\n        // we did not generate this error,\n        // it comes from a throw in some other piece of code\n        err instanceof errors.Unknown ||\n\n        // server sent unparsable JSON\n        err instanceof errors.UnparsableJSON ||\n\n        // max tries and already using fallback or no fallback\n        tries >= client.hosts[initialOpts.hostType].length &&\n        (usingFallback || !hasFallback)) {\n        // stop request implementation for this command\n        err.debugData = debugData;\n        return client._promise.reject(err);\n      }\n\n      // When a timeout occurred, retry by raising timeout\n      if (err instanceof errors.RequestTimeout) {\n        return retryRequestWithHigherTimeout();\n      }\n\n      return retryRequest();\n    }\n\n    function retryRequest() {\n      requestDebug('retrying request');\n      client._incrementHostIndex(initialOpts.hostType);\n      return doRequest(requester, reqOpts);\n    }\n\n    function retryRequestWithHigherTimeout() {\n      requestDebug('retrying request with higher timeout');\n      client._incrementHostIndex(initialOpts.hostType);\n      client._incrementTimeoutMultipler();\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n      return doRequest(requester, reqOpts);\n    }\n  }\n\n  function isCacheValidWithCurrentID(\n    useRequestCache,\n    currentCache,\n    currentCacheID\n  ) {\n    return (\n      client._useCache &&\n      useRequestCache &&\n      currentCache &&\n      currentCache[currentCacheID] !== undefined\n    );\n  }\n\n\n  function interopCallbackReturn(request, callback) {\n    if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n      request.catch(function() {\n        // Release the cache on error\n        delete cache[cacheID];\n      });\n    }\n\n    if (typeof initialOpts.callback === 'function') {\n      // either we have a callback\n      request.then(function okCb(content) {\n        exitPromise(function() {\n          initialOpts.callback(null, callback(content));\n        }, client._setTimeout || setTimeout);\n      }, function nookCb(err) {\n        exitPromise(function() {\n          initialOpts.callback(err);\n        }, client._setTimeout || setTimeout);\n      });\n    } else {\n      // either we are using promises\n      return request.then(callback);\n    }\n  }\n\n  if (client._useCache && client._useRequestCache) {\n    cacheID = initialOpts.url;\n  }\n\n  // as we sometime use POST requests to pass parameters (like query='aa'),\n  // the cacheID must also include the body to be different between calls\n  if (client._useCache && client._useRequestCache && body) {\n    cacheID += '_body_' + body;\n  }\n\n  if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n    requestDebug('serving request from cache');\n\n    var maybePromiseForCache = cache[cacheID];\n\n    // In case the cache is warmup with value that is not a promise\n    var promiseForCache = typeof maybePromiseForCache.then !== 'function'\n      ? client._promise.resolve({responseText: maybePromiseForCache})\n      : maybePromiseForCache;\n\n    return interopCallbackReturn(promiseForCache, function(content) {\n      // In case of the cache request, return the original value\n      return JSON.parse(content.responseText);\n    });\n  }\n\n  var request = doRequest(\n    client._request, {\n      url: initialOpts.url,\n      method: initialOpts.method,\n      body: body,\n      jsonBody: initialOpts.body,\n      timeouts: client._getTimeoutsForRequest(initialOpts.hostType),\n      forceAuthHeaders: initialOpts.forceAuthHeaders\n    }\n  );\n\n  if (client._useCache && client._useRequestCache && cache) {\n    cache[cacheID] = request;\n  }\n\n  return interopCallbackReturn(request, function(content) {\n    // In case of the first request, return the JSON value\n    return content.body;\n  });\n};\n\n/*\n* Transform search param object in query string\n* @param {object} args arguments to add to the current query string\n* @param {string} params current query string\n* @return {string} the final query string\n*/\nAlgoliaSearchCore.prototype._getSearchParams = function(args, params) {\n  if (args === undefined || args === null) {\n    return params;\n  }\n  for (var key in args) {\n    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {\n      params += params === '' ? '' : '&';\n      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);\n    }\n  }\n  return params;\n};\n\n/**\n * Compute the headers for a request\n *\n * @param [string] options.additionalUA semi-colon separated string with other user agents to add\n * @param [boolean=true] options.withApiKey Send the api key as a header\n * @param [Object] options.headers Extra headers to send\n */\nAlgoliaSearchCore.prototype._computeRequestHeaders = function(options) {\n  var forEach = require('foreach');\n\n  var ua = options.additionalUA ?\n    this._ua + '; ' + options.additionalUA :\n    this._ua;\n\n  var requestHeaders = {\n    'x-algolia-agent': ua,\n    'x-algolia-application-id': this.applicationID\n  };\n\n  // browser will inline headers in the url, node.js will use http headers\n  // but in some situations, the API KEY will be too long (big secured API keys)\n  // so if the request is a POST and the KEY is very long, we will be asked to not put\n  // it into headers but in the JSON body\n  if (options.withApiKey !== false) {\n    requestHeaders['x-algolia-api-key'] = this.apiKey;\n  }\n\n  if (this.userToken) {\n    requestHeaders['x-algolia-usertoken'] = this.userToken;\n  }\n\n  if (this.securityTags) {\n    requestHeaders['x-algolia-tagfilters'] = this.securityTags;\n  }\n\n  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {\n    requestHeaders[key] = value;\n  });\n\n  if (options.headers) {\n    forEach(options.headers, function addToRequestHeaders(value, key) {\n      requestHeaders[key] = value;\n    });\n  }\n\n  return requestHeaders;\n};\n\n/**\n * Search through multiple indices at the same time\n * @param  {Object[]}   queries  An array of queries you want to run.\n * @param {string} queries[].indexName The index name you want to target\n * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`\n * @param {Object} queries[].params Any search param like hitsPerPage, ..\n * @param  {Function} callback Callback to be called\n * @return {Promise|undefined} Returns a promise if no callback given\n */\nAlgoliaSearchCore.prototype.search = function(queries, opts, callback) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: client.search(arrayOfQueries[, callback])';\n\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  } else if (opts === undefined) {\n    opts = {};\n  }\n\n  var client = this;\n\n  var postObj = {\n    requests: map(queries, function prepareRequest(query) {\n      var params = '';\n\n      // allow query.query\n      // so we are mimicing the index.search(query, params) method\n      // {indexName:, query:, params:}\n      if (query.query !== undefined) {\n        params += 'query=' + encodeURIComponent(query.query);\n      }\n\n      return {\n        indexName: query.indexName,\n        params: client._getSearchParams(query.params, params)\n      };\n    })\n  };\n\n  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {\n    return requestId + '=' +\n      encodeURIComponent(\n        '/1/indexes/' + encodeURIComponent(request.indexName) + '?' +\n        request.params\n      );\n  }).join('&');\n\n  var url = '/1/indexes/*/queries';\n\n  if (opts.strategy !== undefined) {\n    postObj.strategy = opts.strategy;\n  }\n\n  return this._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url,\n    body: postObj,\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/*',\n      body: {\n        params: JSONPParams\n      }\n    },\n    callback: callback\n  });\n};\n\n/**\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n* This is the top-level API for SFFV.\n*\n* @param {object[]} queries An array of queries to run.\n* @param {string} queries[].indexName Index name, name of the index to search.\n* @param {object} queries[].params Query parameters.\n* @param {string} queries[].params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} queries[].params.facetQuery Query for the facet search\n* @param {string} [queries[].params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n*/\nAlgoliaSearchCore.prototype.searchForFacetValues = function(queries) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: client.searchForFacetValues([{indexName, params: {facetName, facetQuery, ...params}}, ...queries])'; // eslint-disable-line max-len\n\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n\n  var client = this;\n\n  return client._promise.all(map(queries, function performQuery(query) {\n    if (\n      !query ||\n      query.indexName === undefined ||\n      query.params.facetName === undefined ||\n      query.params.facetQuery === undefined\n    ) {\n      throw new Error(usage);\n    }\n\n    var clone = require('./clone.js');\n    var omit = require('./omit.js');\n\n    var indexName = query.indexName;\n    var params = query.params;\n\n    var facetName = params.facetName;\n    var filteredParams = omit(clone(params), function(keyName) {\n      return keyName === 'facetName';\n    });\n    var searchParameters = client._getSearchParams(filteredParams, '');\n\n    return client._jsonRequest({\n      cache: client.cache,\n      method: 'POST',\n      url:\n        '/1/indexes/' +\n        encodeURIComponent(indexName) +\n        '/facets/' +\n        encodeURIComponent(facetName) +\n        '/query',\n      hostType: 'read',\n      body: {params: searchParameters}\n    });\n  }));\n};\n\n/**\n * Set the extra security tagFilters header\n * @param {string|array} tags The list of tags defining the current security filters\n */\nAlgoliaSearchCore.prototype.setSecurityTags = function(tags) {\n  if (Object.prototype.toString.call(tags) === '[object Array]') {\n    var strTags = [];\n    for (var i = 0; i < tags.length; ++i) {\n      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {\n        var oredTags = [];\n        for (var j = 0; j < tags[i].length; ++j) {\n          oredTags.push(tags[i][j]);\n        }\n        strTags.push('(' + oredTags.join(',') + ')');\n      } else {\n        strTags.push(tags[i]);\n      }\n    }\n    tags = strTags.join(',');\n  }\n\n  this.securityTags = tags;\n};\n\n/**\n * Set the extra user token header\n * @param {string} userToken The token identifying a uniq user (used to apply rate limits)\n */\nAlgoliaSearchCore.prototype.setUserToken = function(userToken) {\n  this.userToken = userToken;\n};\n\n/**\n * Clear all queries in client's cache\n * @return undefined\n */\nAlgoliaSearchCore.prototype.clearCache = function() {\n  this.cache = {};\n};\n\n/**\n* Set the number of milliseconds a request can take before automatically being terminated.\n* @deprecated\n* @param {Number} milliseconds\n*/\nAlgoliaSearchCore.prototype.setRequestTimeout = function(milliseconds) {\n  if (milliseconds) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;\n  }\n};\n\n/**\n* Set the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\nAlgoliaSearchCore.prototype.setTimeouts = function(timeouts) {\n  this._timeouts = timeouts;\n};\n\n/**\n* Get the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\nAlgoliaSearchCore.prototype.getTimeouts = function() {\n  return this._timeouts;\n};\n\nAlgoliaSearchCore.prototype._getAppIdData = function() {\n  var data = store.get(this.applicationID);\n  if (data !== null) this._cacheAppIdData(data);\n  return data;\n};\n\nAlgoliaSearchCore.prototype._setAppIdData = function(data) {\n  data.lastChange = (new Date()).getTime();\n  this._cacheAppIdData(data);\n  return store.set(this.applicationID, data);\n};\n\nAlgoliaSearchCore.prototype._checkAppIdData = function() {\n  var data = this._getAppIdData();\n  var now = (new Date()).getTime();\n  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {\n    return this._resetInitialAppIdData(data);\n  }\n\n  return data;\n};\n\nAlgoliaSearchCore.prototype._resetInitialAppIdData = function(data) {\n  var newData = data || {};\n  newData.hostIndexes = {read: 0, write: 0};\n  newData.timeoutMultiplier = 1;\n  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);\n  return this._setAppIdData(newData);\n};\n\nAlgoliaSearchCore.prototype._cacheAppIdData = function(data) {\n  this._hostIndexes = data.hostIndexes;\n  this._timeoutMultiplier = data.timeoutMultiplier;\n  this._shuffleResult = data.shuffleResult;\n};\n\nAlgoliaSearchCore.prototype._partialAppIdDataUpdate = function(newData) {\n  var foreach = require('foreach');\n  var currentData = this._getAppIdData();\n  foreach(newData, function(value, key) {\n    currentData[key] = value;\n  });\n\n  return this._setAppIdData(currentData);\n};\n\nAlgoliaSearchCore.prototype._getHostByType = function(hostType) {\n  return this.hosts[hostType][this._getHostIndexByType(hostType)];\n};\n\nAlgoliaSearchCore.prototype._getTimeoutMultiplier = function() {\n  return this._timeoutMultiplier;\n};\n\nAlgoliaSearchCore.prototype._getHostIndexByType = function(hostType) {\n  return this._hostIndexes[hostType];\n};\n\nAlgoliaSearchCore.prototype._setHostIndexByType = function(hostIndex, hostType) {\n  var clone = require('./clone');\n  var newHostIndexes = clone(this._hostIndexes);\n  newHostIndexes[hostType] = hostIndex;\n  this._partialAppIdDataUpdate({hostIndexes: newHostIndexes});\n  return hostIndex;\n};\n\nAlgoliaSearchCore.prototype._incrementHostIndex = function(hostType) {\n  return this._setHostIndexByType(\n    (this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType\n  );\n};\n\nAlgoliaSearchCore.prototype._incrementTimeoutMultipler = function() {\n  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);\n  return this._partialAppIdDataUpdate({timeoutMultiplier: timeoutMultiplier});\n};\n\nAlgoliaSearchCore.prototype._getTimeoutsForRequest = function(hostType) {\n  return {\n    connect: this._timeouts.connect * this._timeoutMultiplier,\n    complete: this._timeouts[hostType] * this._timeoutMultiplier\n  };\n};\n\nfunction prepareHost(protocol) {\n  return function prepare(host) {\n    return protocol + '//' + host.toLowerCase();\n  };\n}\n\n// Prototype.js < 1.7, a widely used library, defines a weird\n// Array.prototype.toJSON function that will fail to stringify our content\n// appropriately\n// refs:\n//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q\n//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c\n//   - http://stackoverflow.com/a/3148441/147079\nfunction safeJSONStringify(obj) {\n  /* eslint no-extend-native:0 */\n\n  if (Array.prototype.toJSON === undefined) {\n    return JSON.stringify(obj);\n  }\n\n  var toJSON = Array.prototype.toJSON;\n  delete Array.prototype.toJSON;\n  var out = JSON.stringify(obj);\n  Array.prototype.toJSON = toJSON;\n\n  return out;\n}\n\nfunction shuffle(array) {\n  var currentIndex = array.length;\n  var temporaryValue;\n  var randomIndex;\n\n  // While there remain elements to shuffle...\n  while (currentIndex !== 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nfunction removeCredentials(headers) {\n  var newHeaders = {};\n\n  for (var headerName in headers) {\n    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {\n      var value;\n\n      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {\n        value = '**hidden for security purposes**';\n      } else {\n        value = headers[headerName];\n      }\n\n      newHeaders[headerName] = value;\n    }\n  }\n\n  return newHeaders;\n}\n"]},"metadata":{},"sourceType":"script"}